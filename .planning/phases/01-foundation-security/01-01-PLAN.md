---
phase: 01-foundation-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - next.config.ts
  - tailwind.config.ts
  - postcss.config.mjs
  - components.json
  - src/app/layout.tsx
  - src/app/globals.css
  - src/app/page.tsx
  - src/lib/utils.ts
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/crypto/encrypt.ts
  - src/lib/crypto/keys.ts
  - .env.local
autonomous: true

must_haves:
  truths:
    - "npm run dev starts Next.js on port 3000 without errors"
    - "Tailwind CSS with KYN design tokens (primary #10b77f, Space Grotesk, Inter) renders correctly"
    - "Supabase browser and server clients can be imported and instantiated"
    - "encrypt() and decrypt() round-trip a string using AES-256-GCM"
    - "Database schema, RLS policies, and triggers are applied to Supabase"
    - "TypeScript types generated from Supabase schema are importable"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies"
      contains: "@supabase/ssr"
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client"
      exports: ["createClient"]
    - path: "src/lib/supabase/server.ts"
      provides: "Server Supabase client"
      exports: ["createClient"]
    - path: "src/lib/crypto/encrypt.ts"
      provides: "AES-256-GCM encrypt/decrypt"
      exports: ["encrypt", "decrypt"]
    - path: "src/lib/crypto/keys.ts"
      provides: "Key derivation from env"
      exports: ["getEncryptionKey", "deriveKey"]
    - path: "src/lib/utils.ts"
      provides: "cn() utility"
      exports: ["cn"]
    - path: "src/app/globals.css"
      provides: "Tailwind + KYN design tokens CSS variables"
  key_links:
    - from: "src/lib/supabase/client.ts"
      to: "NEXT_PUBLIC_SUPABASE_URL env"
      via: "createBrowserClient()"
      pattern: "createBrowserClient"
    - from: "src/lib/crypto/encrypt.ts"
      to: "src/lib/crypto/keys.ts"
      via: "getEncryptionKey import"
      pattern: "import.*keys"
---

<objective>
Bootstrap entire Next.js 15 project, configure Tailwind with KYN design tokens, set up Supabase clients (browser + server), apply database migrations, generate TypeScript types, and create AES-256-GCM encryption utilities.

Purpose: Every other plan depends on a working Next.js project with Supabase connectivity and encryption. This is the foundation.
Output: Runnable Next.js 15 app with Supabase clients, encryption lib, and design system tokens.
</objective>

<execution_context>
@/Users/charbellelopes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/charbellelopes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-security/01-RESEARCH.md
@reference/shadcn-config.json
@reference/encryption-schemas.ts
@design-system.html
@.env.example
@supabase/001_schema.sql
@supabase/002_rls_policies.sql
@supabase/003_functions_and_triggers.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Next.js 15 project with Shadcn/ui and KYN design tokens</name>
  <files>
    package.json
    tsconfig.json
    next.config.ts
    tailwind.config.ts
    postcss.config.mjs
    components.json
    src/app/layout.tsx
    src/app/globals.css
    src/app/page.tsx
    src/lib/utils.ts
    .env.local
  </files>
  <action>
    1. Initialize Next.js 15 project in current directory (kynapp already has files — use `npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*" --no-turbopack` or equivalent). If create-next-app can't run in non-empty dir, create in temp dir and move files.

    2. Install dependencies:
    ```bash
    npm install @supabase/supabase-js @supabase/ssr react-hook-form zod @hookform/resolvers lucide-react @tanstack/react-query
    ```

    3. Copy `reference/shadcn-config.json` to `components.json` at project root. Then run:
    ```bash
    npx shadcn@latest init --yes
    ```
    If shadcn init prompts despite --yes, use the config from reference/shadcn-config.json (new-york style, rsc: true, tsx: true, cssVariables: true, neutral base color, lucide icons). Install these Shadcn components needed by auth and landing page plans:
    ```bash
    npx shadcn@latest add button input label form card separator badge tabs sheet
    ```

    4. Configure `tailwind.config.ts` with KYN design tokens from `design-system.html`:
    - Extend colors: primary (#10b77f), primary-light (#2cedac), primary-dark (#0d9668), primary-50 through primary-900 scale
    - Semantic: success (#22c55e), warning (#f59e0b), error (hsl(0 72% 51%)), info (#3b82f6)
    - Income (#22c55e) / expense (#ef4444) colors
    - Dark surface colors: dark-bg (hsl(220 25% 7%)), dark-card (hsl(220 20% 12%))
    - Font family: heading = Space Grotesk, body = Inter
    - Border radius: 0.75rem as default 'lg'
    - Extend boxShadow with 'glow': '0 0 40px rgba(16, 183, 127, 0.25)'

    5. Update `src/app/globals.css` with CSS variables matching design-system.html tokens. Include Shadcn/ui CSS variables. Import Google Fonts (Space Grotesk + Inter) via `@import url()` or configure in layout.tsx via `next/font/google`.

    6. Update `src/app/layout.tsx`:
    - Import Space Grotesk and Inter from `next/font/google`
    - Set html lang="pt-BR"
    - Apply Space Grotesk to headings via CSS variable, Inter to body
    - Add metadata: title "KYN - Finanças Pessoais", description in pt-BR, openGraph config
    - Set viewport with theme-color #10b77f

    7. Replace `src/app/page.tsx` with a minimal placeholder that renders "KYN App" with primary color to verify Tailwind works. This will be replaced by landing page in Plan 03.

    8. Create `.env.local` from `.env.example` with actual Supabase values:
    - NEXT_PUBLIC_SUPABASE_URL=https://vonfsyszaxtbxeowelqu.supabase.co
    - NEXT_PUBLIC_SUPABASE_ANON_KEY — get from Supabase project (use `mcp__supabase__get_publishable_keys` tool)
    - ENCRYPTION_KEY — generate with: `node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"`

    9. Update `next.config.ts` with headers for service worker cache control:
    ```typescript
    async headers() {
      return [
        {
          source: '/sw.js',
          headers: [
            { key: 'Cache-Control', value: 'no-cache, no-store, must-revalidate' },
            { key: 'Content-Type', value: 'application/javascript; charset=utf-8' },
          ],
        },
      ]
    }
    ```
  </action>
  <verify>
    Run `npm run dev` — app starts on port 3000 without errors.
    Run `npx tsc --noEmit` — no TypeScript errors.
    Visit localhost:3000 — sees placeholder page with KYN branding and correct font.
  </verify>
  <done>
    Next.js 15 project runs with Tailwind CSS, Shadcn/ui (new-york), KYN design tokens, and Google Fonts configured. All Shadcn components (button, input, form, card, etc.) importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply database migrations and set up Supabase clients</name>
  <files>
    src/lib/supabase/client.ts
    src/lib/supabase/server.ts
    src/types/database.ts
  </files>
  <action>
    1. Apply database migrations to Supabase using MCP tools. Run in order:
    - `mcp__supabase__apply_migration` with name "001_schema" and content from `supabase/001_schema.sql`
    - `mcp__supabase__apply_migration` with name "002_rls_policies" and content from `supabase/002_rls_policies.sql`
    - `mcp__supabase__apply_migration` with name "003_functions_and_triggers" and content from `supabase/003_functions_and_triggers.sql`

    If migrations already applied (errors about existing types/tables), that's fine — the SQL files are the source of truth and may already be in Supabase.

    2. Generate TypeScript types from Supabase schema using `mcp__supabase__generate_typescript_types`. Save output to `src/types/database.ts`.

    3. Create `src/lib/supabase/client.ts` (browser client for Client Components):
    ```typescript
    import { createBrowserClient } from '@supabase/ssr'
    import type { Database } from '@/types/database'

    export function createClient() {
      return createBrowserClient<Database>(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      )
    }
    ```

    4. Create `src/lib/supabase/server.ts` (server client for Server Components + Route Handlers):
    ```typescript
    import { createServerClient } from '@supabase/ssr'
    import { cookies } from 'next/headers'
    import type { Database } from '@/types/database'

    export async function createClient() {
      const cookieStore = await cookies()

      return createServerClient<Database>(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
          cookies: {
            getAll() {
              return cookieStore.getAll()
            },
            setAll(cookiesToSet) {
              try {
                cookiesToSet.forEach(({ name, value, options }) =>
                  cookieStore.set(name, value, options)
                )
              } catch {
                // setAll called from Server Component — ignore
                // Middleware (proxy.ts) will handle cookie refresh
              }
            },
          },
        }
      )
    }
    ```

    5. Verify with `mcp__supabase__list_tables` that all tables exist. Run `mcp__supabase__get_advisors` for security check — verify no missing RLS warnings.

    Note: Use `NEXT_PUBLIC_SUPABASE_ANON_KEY` env var name (not publishable key) since the .env.example already uses this convention. Get the actual key value via `mcp__supabase__get_publishable_keys`.
  </action>
  <verify>
    `mcp__supabase__list_tables` returns all 13 tables (profiles, bank_accounts, credit_cards, transactions, etc.).
    `mcp__supabase__get_advisors` type=security shows no critical issues.
    `npx tsc --noEmit` passes with database types imported.
  </verify>
  <done>
    Database schema with RLS applied to Supabase. TypeScript Database type generated and importable. Browser and server Supabase clients created with proper cookie handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AES-256-GCM encryption utilities with Web Crypto API</name>
  <files>
    src/lib/crypto/keys.ts
    src/lib/crypto/encrypt.ts
  </files>
  <action>
    1. Create `src/lib/crypto/keys.ts` — Key derivation and management:
    ```typescript
    // Derive AES-256-GCM CryptoKey from environment variable using PBKDF2
    // ENCRYPTION_KEY env var is a base64-encoded 32-byte key
    // For Phase 1: shared key stored in env (not per-user)

    const SALT = new Uint8Array([/* 16 fixed bytes — generate once and hardcode */])
    // Generate salt: crypto.getRandomValues(new Uint8Array(16))
    // Hardcode the result so all encrypt/decrypt use same salt

    let cachedKey: CryptoKey | null = null

    export async function getEncryptionKey(): Promise<CryptoKey> {
      if (cachedKey) return cachedKey

      const keyBase64 = process.env.NEXT_PUBLIC_ENCRYPTION_KEY || process.env.ENCRYPTION_KEY
      if (!keyBase64) throw new Error('ENCRYPTION_KEY not configured')

      const keyBytes = Uint8Array.from(atob(keyBase64), c => c.charCodeAt(0))

      const keyMaterial = await crypto.subtle.importKey(
        'raw', keyBytes, 'PBKDF2', false, ['deriveBits', 'deriveKey']
      )

      cachedKey = await crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt: SALT, iterations: 100000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false, // not extractable
        ['encrypt', 'decrypt']
      )

      return cachedKey
    }

    // Export deriveKey for testing purposes
    export async function deriveKey(password: string, salt: Uint8Array): Promise<CryptoKey> { ... }
    ```

    Use `NEXT_PUBLIC_ENCRYPTION_KEY` so it's available in browser context for client-side encrypt/decrypt. Document in .env.example.

    2. Create `src/lib/crypto/encrypt.ts` — Encrypt/decrypt functions:
    ```typescript
    import { getEncryptionKey } from './keys'

    // Encrypt plaintext → base64 string (iv + ciphertext)
    export async function encrypt(plaintext: string): Promise<string> {
      const key = await getEncryptionKey()
      const encoder = new TextEncoder()
      const data = encoder.encode(plaintext)
      const iv = crypto.getRandomValues(new Uint8Array(12)) // 12-byte IV for AES-GCM

      const ciphertext = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        key,
        data
      )

      // Combine IV (12 bytes) + ciphertext, encode as base64
      const combined = new Uint8Array(iv.length + new Uint8Array(ciphertext).length)
      combined.set(iv, 0)
      combined.set(new Uint8Array(ciphertext), iv.length)

      return btoa(String.fromCharCode(...combined))
    }

    // Decrypt base64 string → plaintext
    export async function decrypt(encrypted: string): Promise<string> {
      const key = await getEncryptionKey()
      const combined = Uint8Array.from(atob(encrypted), c => c.charCodeAt(0))

      const iv = combined.slice(0, 12)
      const ciphertext = combined.slice(12)

      const plaintext = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv },
        key,
        ciphertext
      )

      return new TextDecoder().decode(plaintext)
    }

    // Encrypt a numeric value (stored as TEXT in DB)
    export async function encryptNumber(value: number): Promise<string> {
      return encrypt(value.toString())
    }

    // Decrypt to number
    export async function decryptNumber(encrypted: string): Promise<number> {
      const plaintext = await decrypt(encrypted)
      return parseFloat(plaintext)
    }

    // Encrypt multiple fields of an object based on ENCRYPTED_FIELDS map
    export async function encryptFields<T extends Record<string, any>>(
      tableName: string,
      data: T
    ): Promise<T> { ... }

    // Decrypt multiple fields
    export async function decryptFields<T extends Record<string, any>>(
      tableName: string,
      data: T
    ): Promise<T> { ... }
    ```

    Import the ENCRYPTED_FIELDS map from a constants file (copy from reference/encryption-schemas.ts into src/lib/crypto/fields.ts — this one IS imported by app code, unlike the reference file).

    3. Add `NEXT_PUBLIC_ENCRYPTION_KEY` to `.env.example` and `.env.local`. Generate a real key for .env.local.

    4. Verify encrypt→decrypt round-trip works by adding a simple test or by running in Node REPL.
  </action>
  <verify>
    `npx tsc --noEmit` passes.
    Quick verification: In a test script or dev console, `encrypt("R$ 1234.56")` produces a base64 string, and `decrypt(result)` returns "R$ 1234.56".
    `encryptNumber(1234.56)` → encrypt → `decryptNumber(result)` → 1234.56.
  </verify>
  <done>
    AES-256-GCM encryption utilities work with Web Crypto API. encrypt/decrypt/encryptNumber/decryptNumber/encryptFields/decryptFields all exported and functional. Key derived from ENCRYPTION_KEY env var via PBKDF2.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. `npx tsc --noEmit` passes
3. localhost:3000 renders with KYN design tokens
4. Supabase tables exist with RLS enabled
5. Encryption round-trip works
</verification>

<success_criteria>
- Next.js 15 project fully configured with Tailwind CSS, Shadcn/ui (new-york), design tokens
- Supabase browser + server clients importable and typed with Database generic
- Database schema + RLS + triggers applied to Supabase
- AES-256-GCM encrypt/decrypt utilities functional
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-01-SUMMARY.md`
</output>
