---
phase: 03-analysis-and-automation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/queries/recurring.ts
  - src/lib/validators/recurring.ts
  - src/components/recurrents/recurring-form.tsx
  - src/components/recurrents/recurring-item.tsx
  - src/components/recurrents/recurring-list.tsx
  - src/app/(app)/recorrentes/page.tsx
  - supabase/004_recurring_cron.sql
autonomous: true

must_haves:
  truths:
    - "User can create recurring transaction with day of month and end date"
    - "System auto-generates monthly transactions from recurring template"
    - "User sees list of active recurring groups (income and expense separately)"
    - "User can delete all future transactions of a recurring group"
    - "User can edit a single occurrence of a recurring transaction"
  artifacts:
    - path: "src/lib/queries/recurring.ts"
      provides: "TanStack Query hooks for recurring templates CRUD + delete future"
      exports: ["useRecurringTemplates", "useCreateRecurring", "useDeleteRecurring", "useDeleteFutureTransactions"]
    - path: "src/lib/validators/recurring.ts"
      provides: "Zod schema for recurring form"
      exports: ["recurringSchema"]
    - path: "src/components/recurrents/recurring-form.tsx"
      provides: "Form to create recurring template"
    - path: "src/components/recurrents/recurring-list.tsx"
      provides: "Grouped list: income templates then expense templates"
    - path: "src/app/(app)/recorrentes/page.tsx"
      provides: "Recurring management page"
    - path: "supabase/004_recurring_cron.sql"
      provides: "pg_cron job for monthly auto-generation"
      contains: "cron.schedule"
  key_links:
    - from: "src/app/(app)/recorrentes/page.tsx"
      to: "src/lib/queries/recurring.ts"
      via: "useRecurringTemplates hook"
      pattern: "useRecurringTemplates"
    - from: "src/components/recurrents/recurring-form.tsx"
      to: "src/lib/queries/recurring.ts"
      via: "useCreateRecurring mutation"
      pattern: "useCreateRecurring"
    - from: "supabase/004_recurring_cron.sql"
      to: "recurring_templates table"
      via: "SQL function reads templates, inserts transactions"
      pattern: "generate_recurring_transactions"
---

<objective>
Recurring transaction templates with CRUD, auto-generation via pg_cron, and group management.

Purpose: Users with fixed monthly expenses (rent, subscriptions, salary) shouldn't re-enter them every month. Templates auto-generate planned transactions on the 1st of each month.
Output: Working /app/recorrentes page with template list, create form, delete future, and SQL migration for cron job.
</objective>

<execution_context>
@/Users/charbellelopes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/charbellelopes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-analysis-and-automation/03-RESEARCH.md
@.planning/phases/03-analysis-and-automation/03-01-SUMMARY.md
@src/types/database.ts
@src/lib/queries/transactions.ts
@src/lib/validators/transaction.ts
@src/hooks/use-media-query.ts
@src/components/transactions/transaction-form.tsx
@reference/categories.ts
@reference/encryption-schemas.ts
@supabase/001_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Recurring queries + validators</name>
  <files>
    src/lib/queries/recurring.ts
    src/lib/validators/recurring.ts
  </files>
  <action>
1. Create src/lib/validators/recurring.ts — Zod schema:
   - `recurringSchema` = z.object:
     - description: z.string().min(1, 'Descricao obrigatoria')
     - amount: z.number().positive('Valor deve ser positivo')
     - type: z.enum(['income', 'expense'])
     - category: expense_category enum (nullable, optional — only for expenses)
     - day_of_month: z.number().int().min(1).max(31)
     - end_date: z.string().regex date format — REQUIRED (research says default +12 months to avoid infinite generation)
     - payment_method: payment_method enum (nullable, optional)
     - bank_account_id: z.string().uuid().nullable().optional()
     - credit_card_id: z.string().uuid().nullable().optional()
   - Export `RecurringInput` type.

2. Create src/lib/queries/recurring.ts — TanStack Query hooks:
   - `DecryptedRecurring` type: Omit description/amount from Row, add description (string) + amount (number)
   - `useRecurringTemplates()`: fetch all recurring_templates for current user where is_active=true, decrypt description + amount. queryKey: ['recurring-templates']. Order by type (income first), then day_of_month.
   - `useCreateRecurring()`: mutation. Takes RecurringInput. Encrypts description + amount. Inserts into recurring_templates with user_id from getUser(). On success invalidate ['recurring-templates']. Also immediately generate the first transaction for current month if day_of_month >= today's day (insert into transactions with is_recurring=true, recurring_group_id=template.id, status='planned', due_date calculated using LEAST logic for current month).
   - `useDeleteRecurring()`: mutation. Takes template id. Sets is_active=false (soft delete). Also deletes all future transactions (due_date > today) with recurring_group_id matching template id. Invalidate ['recurring-templates'] and ['transactions'].
   - `useDeleteFutureTransactions(templateId)`: mutation. Deletes transactions where recurring_group_id = templateId AND due_date > today AND status = 'planned'. Invalidate ['transactions'].
   - Note: "Edit single occurrence" (RECR-05) = just editing the generated transaction via existing useUpdateTransaction. No new hook needed — the transaction form already handles this.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>Recurring template CRUD with encryption. Delete future transactions. Validator enforces required end_date.</done>
</task>

<task type="auto">
  <name>Task 2: Recurring UI components</name>
  <files>
    src/components/recurrents/recurring-form.tsx
    src/components/recurrents/recurring-item.tsx
    src/components/recurrents/recurring-list.tsx
  </files>
  <action>
1. Create src/components/recurrents/recurring-item.tsx — Single template display:
   - Props: recurring (DecryptedRecurring), onDelete (id) => void
   - Show: icon (category icon from categoryIcons), description, formatCurrency(amount), "Dia {day_of_month}" badge, type badge (income=green, expense=red).
   - Delete button with AlertDialog confirmation: "Excluir recorrente? Todas as transacoes futuras serao removidas."
   - Card component, compact layout.

2. Create src/components/recurrents/recurring-list.tsx — Grouped list:
   - Props: templates (DecryptedRecurring[]), onDelete (id) => void
   - Split into two sections: "Receitas Recorrentes" (type=income) and "Despesas Recorrentes" (type=expense)
   - Each section: heading + list of RecurringItem
   - If section empty: subtle "Nenhuma {receita/despesa} recorrente" text
   - If all empty: empty state with "Crie templates para automatizar lancamentos mensais"

3. Create src/components/recurrents/recurring-form.tsx — Create new template:
   - Uses React Hook Form + Zod (recurringSchema)
   - Fields: description (text), amount (currency input), type (income/expense toggle), category (select — only shown for expenses), day_of_month (number 1-31), end_date (date input, default 12 months from today), payment_method (select), bank_account_id/credit_card_id (conditional — same pattern as transaction form: credit shows cards, otherwise accounts).
   - Uses useAccounts and useCards queries for selectors (already exist from Phase 2).
   - Sheet on mobile, Dialog on desktop (useMediaQuery pattern).
   - Submit calls useCreateRecurring.
   - Button: "Criar Recorrente"
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>Recurring item, list (grouped by type), and form with all fields including conditional account/card selector.</done>
</task>

<task type="auto">
  <name>Task 3: Recurring page + pg_cron SQL migration</name>
  <files>
    src/app/(app)/recorrentes/page.tsx
    supabase/004_recurring_cron.sql
  </files>
  <action>
1. Create src/app/(app)/recorrentes/page.tsx — 'use client' page:
   - Use useRecurringTemplates() to fetch active templates
   - Layout: "Recorrentes" title + "Novo" button (opens RecurringForm)
   - RecurringList with templates
   - Delete handler: calls useDeleteRecurring mutation
   - Loading state: skeleton cards
   - No month selector needed (templates are global, not month-specific)

2. Create supabase/004_recurring_cron.sql — pg_cron auto-generation:
   - CREATE EXTENSION IF NOT EXISTS pg_cron (with schema=cron if needed)
   - CREATE OR REPLACE FUNCTION generate_recurring_transactions() RETURNS void LANGUAGE plpgsql SECURITY DEFINER:
     - Loop over recurring_templates WHERE is_active = true
     - For each: check if end_date is null or end_date >= current month start
     - Calculate target_date using LEAST(day_of_month, last-day-of-month) to handle Feb/30-day months
     - Check NOT EXISTS transaction with same recurring_group_id + due_date in same month (prevent duplicates)
     - INSERT transaction with: user_id, description (encrypted — copy directly from template since both are encrypted TEXT), amount (same), type, category, custom_category_id, status='planned', due_date=target_date, is_recurring=true, recurring_day=day_of_month, recurring_group_id=template.id, payment_method, bank_account_id, credit_card_id
   - SELECT cron.schedule('generate-recurring-transactions', '1 0 1 * *', $$SELECT generate_recurring_transactions();$$)
   - Add comment explaining: runs 00:01 on 1st of every month, copies encrypted values directly (no decrypt/re-encrypt needed since same encryption key)
  </action>
  <verify>npm run build passes. SQL file is valid (can review syntax). Page renders at /app/recorrentes.</verify>
  <done>Recurring page shows grouped templates (income/expense). Form creates templates. Delete removes template + future transactions. SQL migration ready for pg_cron setup. RECR-01 through RECR-05 covered.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- /app/recorrentes page accessible
- Recurring form creates templates with encrypted fields
- Delete removes template and future planned transactions
- SQL migration file ready (004_recurring_cron.sql)
- RECR-05 (edit single occurrence) handled by existing transaction form
</verification>

<success_criteria>
1. User can create recurring template with description, amount, day_of_month, end_date
2. User sees templates grouped by income/expense
3. User can delete template (soft delete + removes future planned transactions)
4. SQL function generates transactions monthly via pg_cron (copies encrypted values directly)
5. Single occurrence editable via existing transaction editing flow
</success_criteria>

<output>
After completion, create `.planning/phases/03-analysis-and-automation/03-02-SUMMARY.md`
</output>
